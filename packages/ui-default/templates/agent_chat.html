
{% block content %}
<div class="row">
  <div class="medium-12 columns">
    <div class="section">
      <div class="section__header">
        <h1 class="section__title">{{ adoc.title }} - {{ _('Chat') }}</h1>
        <div class="section__tools">
          <a href="{{ url('agent_detail', domainId=domainId, aid=adoc.aid) }}" class="button">
            <span class="icon icon-back"></span> {{ _('Back to Agent') }}
          </a>
        </div>
      </div>
      <div class="section__body">
        <div style="margin-bottom: 12px;">
          <span id="mcpStatus" class="mcp-status">MCP: Checking...</span>
        </div>

        {% if not apiKey or apiKey == '' %}
        <div style="padding: 12px; background: #f48771; color: white; border-radius: 4px; margin-bottom: 16px;">
          <p>⚠️ {{ _('API Key not configured. Please configure AI settings in system settings') }}</p>
        </div>
        {% endif %}

        <div id="chatContainer" style="display: flex; flex-direction: column; height: 70vh; border: 1px solid #e0e0e0; border-radius: 8px; background: #f9f9f9;">
          <div class="chat-messages" id="chatMessages" style="flex: 1; overflow-y: auto; padding: 16px;"></div>
          <div style="display: flex; padding: 16px; border-top: 1px solid #e0e0e0; background: white;">
            <textarea id="chatInput" placeholder="{{ _('Type your message...') }}" rows="3" style="flex: 1; margin-right: 12px; padding: 12px; border: 1px solid #e0e0e0; border-radius: 4px; resize: none; font-family: inherit;"></textarea>
            <button id="sendButton" class="button" style="padding: 12px 24px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background 0.2s;">{{ _('Send') }}</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .chat-message {
    margin-bottom: 16px;
    padding: 12px;
    border-radius: 8px;
    max-width: 80%;
    word-wrap: break-word;
  }
  .chat-message.user {
    background: #007acc;
    color: white;
    margin-left: auto;
    text-align: right;
  }
  .chat-message.assistant {
    background: #e0e0e0;
    color: #333;
    margin-right: auto;
  }
  .chat-message.error {
    background: #f48771;
    color: white;
    max-width: 100%;
  }
  .mcp-status {
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 4px;
    background: #e0e0e0;
    display: inline-block;
  }
  .mcp-status.connected {
    background: #4caf50;
    color: white;
  }
  .mcp-status.disconnected {
    background: #f44336;
    color: white;
  }
  .button:hover {
    background: #005999;
  }
  .button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  .loading {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid #ccc;
    border-top-color: #007acc;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>

<script>
(function() {
  const chatMessages = document.getElementById('chatMessages');
  const chatInput = document.getElementById('chatInput');
  const sendButton = document.getElementById('sendButton');
  const mcpStatus = document.getElementById('mcpStatus');

  let history = [];

  async function checkMcpStatus() {
    try {
      const response = await fetch('{{ url("agent_mcp_status", domainId=domainId, aid=adoc.aid) }}', { 
        method: 'GET'
      });
      const data = await response.json();
      if (data.connected) {
        mcpStatus.textContent = `MCP: Connected (${data.toolCount} tools)`;
        mcpStatus.className = 'mcp-status connected';
      } else {
        mcpStatus.textContent = 'MCP: Disconnected';
        mcpStatus.className = 'mcp-status disconnected';
      }
    } catch (e) {
      mcpStatus.textContent = 'MCP: Disconnected';
      mcpStatus.className = 'mcp-status disconnected';
    }
  }

  checkMcpStatus();

  function addMessage(role, content) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${role}`;
    messageDiv.textContent = content;
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function setLoading(loading) {
    sendButton.disabled = loading;
    if (loading && !sendButton.querySelector('.loading')) {
      const loader = document.createElement('span');
      loader.className = 'loading';
      sendButton.innerHTML = '{{ _("Sending...") }} ';
      sendButton.appendChild(loader);
    } else if (!loading) {
      sendButton.textContent = '{{ _("Send") }}';
    }
  }

  async function sendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;

    addMessage('user', message);
    chatInput.value = '';
    setLoading(true);

    try {
      const formData = new FormData();
      formData.append('message', message);
      formData.append('history', JSON.stringify(history));
      formData.append('stream', 'true');

      const response = await fetch('{{ url("agent_chat", domainId=domainId, aid=adoc.aid) }}?stream=true', {
        method: 'POST',
        body: formData
      });

      const contentType = response.headers.get('content-type') || '';
      const isStream = contentType.includes('text/event-stream');
      
      if (isStream && response.body) {
        console.log('开始处理流式响应，Content-Type:', contentType);
        try {
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let assistantMessageDiv = null;
          let accumulatedContent = '';
          let hasReceivedData = false;
          let chunkCount = 0;
          let contentUpdateCount = 0;

          assistantMessageDiv = document.createElement('div');
          assistantMessageDiv.className = 'chat-message assistant';
          assistantMessageDiv.textContent = '';
          chatMessages.appendChild(assistantMessageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;

          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('流读取完成，共收到', chunkCount, '个数据块，', contentUpdateCount, '次内容更新');
              if (!hasReceivedData) {
                if (assistantMessageDiv) {
                  assistantMessageDiv.remove();
                }
                addMessage('error', '连接已关闭，未收到任何数据');
              }
              break;
            }

            chunkCount++;
            hasReceivedData = true;
            
            const chunk = decoder.decode(value, { stream: true });
            buffer += chunk;
            
            let processedAny = false;
            let lastUpdateTime = Date.now();
            
            while (buffer.includes('\n')) {
              const newlineIndex = buffer.indexOf('\n');
              const line = buffer.substring(0, newlineIndex);
              buffer = buffer.substring(newlineIndex + 1);
              
              if (!line.trim()) continue;
              
              if (line.startsWith('data: ')) {
                const data = line.slice(6).trim();
                if (data === '[DONE]') {
                  console.log('收到 [DONE] 信号');
                  continue;
                }
                if (!data) continue;
                
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.type === 'content' && parsed.content) {
                    contentUpdateCount++;
                    accumulatedContent += parsed.content;
                    
                    assistantMessageDiv.innerText = accumulatedContent;
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    
                    processedAny = true;
                    
                    if (contentUpdateCount <= 10 || contentUpdateCount % 10 === 0) {
                      console.log('[流式] 更新 #' + contentUpdateCount, '新增内容:', parsed.content, '总长度:', accumulatedContent.length);
                    }
                    
                    const now = Date.now();
                    const timeSinceLastUpdate = now - lastUpdateTime;
                    const minInterval = 30;
                    if (timeSinceLastUpdate < minInterval) {
                      await new Promise(resolve => setTimeout(resolve, minInterval - timeSinceLastUpdate));
                    }
                    lastUpdateTime = Date.now();
                    
                    requestAnimationFrame(() => {
                      if (assistantMessageDiv) {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                      }
                    });
                  } else if (parsed.type === 'done') {
                    console.log('收到 done 信号，完整消息长度:', parsed.message?.length || 0);
                    history = JSON.parse(parsed.history);
                    if (assistantMessageDiv) {
                      assistantMessageDiv.textContent = parsed.message || accumulatedContent;
                    }
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    break;
                  } else if (parsed.type === 'error') {
                    console.error('收到错误:', parsed.error);
                    addMessage('error', parsed.error);
                    break;
                  }
                } catch (e) {
                  console.error('Parse error:', e, 'Line:', line.substring(0, 100));
                }
              } else {
                console.log('Skip line:', line.substring(0, 50));
              }
            }
          }
        } catch (streamError) {
          console.error('Stream read error:', streamError);
          addMessage('error', '读取流式响应时出错: ' + streamError.message);
        }
      } else {
        const responseText = await response.text();
        
        if (responseText.includes('data: ') && !isStream) {
          const lines = responseText.split('\n');
          let assistantMessageDiv = null;
          let accumulatedContent = '';
          
          for (const line of lines) {
            if (!line.trim() || !line.startsWith('data: ')) continue;
            const data = line.slice(6);
            if (data === '[DONE]') break;
            
            try {
              const parsed = JSON.parse(data);
              if (parsed.type === 'content') {
                if (!assistantMessageDiv) {
                  assistantMessageDiv = document.createElement('div');
                  assistantMessageDiv.className = 'chat-message assistant';
                  chatMessages.appendChild(assistantMessageDiv);
                }
                accumulatedContent += parsed.content;
                assistantMessageDiv.textContent = accumulatedContent;
                chatMessages.scrollTop = chatMessages.scrollHeight;
              } else if (parsed.type === 'done') {
                history = JSON.parse(parsed.history);
                if (assistantMessageDiv) {
                  assistantMessageDiv.textContent = parsed.message;
                }
                chatMessages.scrollTop = chatMessages.scrollHeight;
              } else if (parsed.type === 'error') {
                addMessage('error', parsed.error);
                return;
              }
            } catch (e) {
            }
          }
          
          if (assistantMessageDiv) {
            return;
          }
        }
        
        let data;
        try {
          data = JSON.parse(responseText);
        } catch (e) {
          console.error('Response is not JSON:', responseText.substring(0, 200));
          if (responseText.trim()) {
            addMessage('error', '服务器返回了意外的响应格式: ' + responseText.substring(0, 100));
          } else {
            addMessage('error', '服务器返回了空响应');
          }
          return;
        }
        
        if (data.error) {
          addMessage('error', data.error);
        } else {
          addMessage('assistant', data.message);
          history = JSON.parse(data.history);
        }
      }
    } catch (error) {
      addMessage('error', '{{ _("Send failed") }}: ' + error.message);
    } finally {
      setLoading(false);
    }
  }

  sendButton.addEventListener('click', sendMessage);
  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
})();
</script>
{% endblock %}


