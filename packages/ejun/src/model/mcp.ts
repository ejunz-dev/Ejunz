import { Filter, ObjectId } from 'mongodb';
import { Context } from '../context';
import { Logger } from '../logger';
import db from '../service/db';
import * as document from './document';
import type { McpServerDoc, McpToolDoc } from '../interface';
import { randomstring } from '../utils';

const logger = new Logger('model/mcp');

class McpServerModel {
    static async generateNextServerId(domainId: string): Promise<number> {
        const lastServer = await document.getMulti(domainId, document.TYPE_MCP_SERVER, {})
            .sort({ serverId: -1 })
            .limit(1)
            .project({ serverId: 1 })
            .toArray();
        return (lastServer[0]?.serverId || 0) + 1;
    }

    static async generateWsToken(): Promise<string> {
        return randomstring(32);
    }

    static async add(server: Partial<McpServerDoc> & { domainId: string; name: string; owner: number }): Promise<McpServerDoc> {
        const serverId = await this.generateNextServerId(server.domainId);
        const now = new Date();
        
        const payload: Partial<McpServerDoc> = {
            domainId: server.domainId,
            serverId,
            name: server.name,
            description: server.description,
            wsEndpoint: server.wsEndpoint || `/mcp/ws`,
            wsToken: server.wsToken || null,
            // 不再设置 status 字段，状态由实时连接管理，不存储到数据库
            lastConnectedAt: server.lastConnectedAt,
            lastDisconnectedAt: server.lastDisconnectedAt,
            errorMessage: server.errorMessage,
            toolsCount: server.toolsCount || 0,
            type: server.type || 'provider', // 默认为 provider
            createdAt: now,
            updatedAt: now,
            owner: server.owner,
        };

        // docId is auto-generated by mongo (ObjectId), serverId is business ID (starts from 1)
        await document.add(
            server.domainId,
            server.name, // content
            server.owner,
            document.TYPE_MCP_SERVER,
            null,
            null,
            null,
            payload,
        );

        return await this.getByServerId(server.domainId, serverId) as McpServerDoc;
    }

    // Find server by name (used to check if exists during auto-registration)
    static async getByName(domainId: string, name: string): Promise<McpServerDoc | null> {
        const servers = await document.getMulti(domainId, document.TYPE_MCP_SERVER, { name })
            .limit(1)
            .toArray();
        return (servers[0] as McpServerDoc) || null;
    }

    static async get(_id: ObjectId): Promise<McpServerDoc | null> {
        const doc = await document.coll.findOne({ _id });
        if (!doc) return null;
        return await this.getByServerId(doc.domainId, doc.serverId);
    }

    static async getByDomain(domainId: string): Promise<McpServerDoc[]> {
        return await document.getMulti(domainId, document.TYPE_MCP_SERVER, {}).toArray() as McpServerDoc[];
    }

    static async getByOwner(domainId: string, owner: number): Promise<McpServerDoc[]> {
        return await document.getMulti(domainId, document.TYPE_MCP_SERVER, { owner }).toArray() as McpServerDoc[];
    }

    static async update(domainId: string, serverId: number, update: Partial<McpServerDoc>): Promise<McpServerDoc> {
        const server = await this.getByServerId(domainId, serverId);
        if (!server) throw new Error('MCP Server not found');
        const $set = { ...update, updatedAt: new Date() };
        return await document.set(domainId, document.TYPE_MCP_SERVER, server.docId, $set) as McpServerDoc;
    }

    static async updateStatus(
        domainId: string,
        serverId: number,
        status: 'connected' | 'disconnected' | 'error',
        errorMessage?: string,
    ): Promise<McpServerDoc> {
        const now = new Date();
        const update: Partial<McpServerDoc> = {
            status,
            updatedAt: now,
        };
        if (status === 'connected') {
            update.lastConnectedAt = now;
            update.errorMessage = undefined;
        } else if (status === 'disconnected') {
            update.lastDisconnectedAt = now;
        } else if (status === 'error') {
            update.errorMessage = errorMessage;
        }
        return await this.update(domainId, serverId, update);
    }

    static async del(domainId: string, serverId: number) {
        const server = await this.getByServerId(domainId, serverId);
        if (!server) return;
        // Delete related tools when deleting server
        await McpToolModel.deleteByServer(domainId, server.docId);
        return await document.deleteOne(domainId, document.TYPE_MCP_SERVER, server.docId);
    }

    static async getByServerId(domainId: string, serverId: number): Promise<McpServerDoc | null> {
        const servers = await document.getMulti(domainId, document.TYPE_MCP_SERVER, { serverId })
            .limit(1)
            .toArray();
        return (servers[0] as McpServerDoc) || null;
    }

    static async getByWsEndpoint(domainId: string, wsEndpoint: string): Promise<McpServerDoc | null> {
        const servers = await document.getMulti(domainId, document.TYPE_MCP_SERVER, { wsEndpoint })
            .limit(1)
            .toArray();
        return (servers[0] as McpServerDoc) || null;
    }
}

class McpToolModel {
    static async generateNextToolId(domainId: string, serverId: number): Promise<number> {
        const lastTool = await document.getMulti(domainId, document.TYPE_MCP_TOOL, { serverId })
            .sort({ toolId: -1 })
            .limit(1)
            .project({ toolId: 1 })
            .toArray();
        return (lastTool[0]?.toolId || 0) + 1;
    }

    static async add(
        tool: Partial<McpToolDoc> & {
            domainId: string;
            serverId: number;
            serverDocId: ObjectId;
            name: string;
            description: string;
            inputSchema: McpToolDoc['inputSchema'];
            owner: number;
        },
    ): Promise<McpToolDoc> {
        const toolId = await this.generateNextToolId(tool.domainId, tool.serverId);
        const now = new Date();
        
        const payload: Partial<McpToolDoc> = {
            domainId: tool.domainId,
            serverId: tool.serverId,
            serverDocId: tool.serverDocId,
            toolId,
            name: tool.name,
            description: tool.description,
            inputSchema: tool.inputSchema,
            createdAt: now,
            updatedAt: now,
            owner: tool.owner,
        };

        await document.add(
            tool.domainId,
            tool.name, // content
            tool.owner,
            document.TYPE_MCP_TOOL,
            null,
            null,
            null,
            payload,
        );

        const server = await McpServerModel.getByServerId(tool.domainId, tool.serverId);
        if (server) {
            const toolsCount = await this.countByServer(tool.domainId, tool.serverId);
            await McpServerModel.update(tool.domainId, tool.serverId, { toolsCount });
        }

        return await this.getByToolId(tool.domainId, tool.serverId, toolId) as McpToolDoc;
    }

    static async get(_id: ObjectId): Promise<McpToolDoc | null> {
        const doc = await document.coll.findOne({ _id });
        if (!doc) return null;
        return await this.getByToolId(doc.domainId, doc.serverId, doc.toolId);
    }

    static async getByServer(domainId: string, serverId: number): Promise<McpToolDoc[]> {
        return await document.getMulti(domainId, document.TYPE_MCP_TOOL, { serverId }).toArray() as McpToolDoc[];
    }

    static async getByServerDocId(domainId: string, serverDocId: ObjectId): Promise<McpToolDoc[]> {
        return await document.getMulti(domainId, document.TYPE_MCP_TOOL, { serverDocId }).toArray() as McpToolDoc[];
    }

    static async update(domainId: string, serverId: number, toolId: number, update: Partial<McpToolDoc>): Promise<McpToolDoc> {
        const tool = await this.getByToolId(domainId, serverId, toolId);
        if (!tool) throw new Error('MCP Tool not found');
        const $set = { ...update, updatedAt: new Date() };
        return await document.set(domainId, document.TYPE_MCP_TOOL, tool.docId, $set) as McpToolDoc;
    }

    static async del(domainId: string, serverId: number, toolId: number) {
        const tool = await this.getByToolId(domainId, serverId, toolId);
        if (!tool) return;
        await document.deleteOne(domainId, document.TYPE_MCP_TOOL, tool.docId);
        
        const server = await McpServerModel.getByServerId(domainId, serverId);
        if (server) {
            const toolsCount = await this.countByServer(domainId, serverId);
            await McpServerModel.update(domainId, serverId, { toolsCount });
        }
    }

    static async deleteByServer(domainId: string, serverDocId: ObjectId) {
        return await document.deleteMulti(domainId, document.TYPE_MCP_TOOL, { serverDocId });
    }

    static async getByToolId(domainId: string, serverId: number, toolId: number): Promise<McpToolDoc | null> {
        const tools = await document.getMulti(domainId, document.TYPE_MCP_TOOL, { serverId, toolId })
            .limit(1)
            .toArray();
        return (tools[0] as McpToolDoc) || null;
    }

    static async countByServer(domainId: string, serverId: number): Promise<number> {
        return await document.count(domainId, document.TYPE_MCP_TOOL, { serverId });
    }

    // Clean up duplicate tools (keep only the one with smallest toolId for each tool name)
    static async cleanupDuplicates(domainId: string, serverId: number): Promise<number> {
        const existingTools = await this.getByServer(domainId, serverId);
        
        const sortedTools = existingTools.sort((a, b) => a.toolId - b.toolId);
        
        const toolNameToFirstId = new Map<string, number>();
        const duplicateToolIds: number[] = [];
        
        for (const tool of sortedTools) {
            if (!toolNameToFirstId.has(tool.name)) {
                toolNameToFirstId.set(tool.name, tool.toolId);
            } else {
                duplicateToolIds.push(tool.toolId);
                logger.warn('Found duplicate tool: %s (toolId: %d), will be removed (keeping toolId: %d)', 
                    tool.name, tool.toolId, toolNameToFirstId.get(tool.name));
            }
        }
        
        let deletedCount = 0;
        for (const toolId of duplicateToolIds) {
            await this.del(domainId, serverId, toolId);
            deletedCount++;
        }
        
        if (deletedCount > 0) {
            logger.info('Cleaned up %d duplicate tools: serverId=%d', deletedCount, serverId);
            const toolsCount = await this.countByServer(domainId, serverId);
            await McpServerModel.update(domainId, serverId, { toolsCount });
        }
        
        return deletedCount;
    }

    static async syncToolsFromServer(
        domainId: string,
        serverId: number,
        serverDocId: ObjectId,
        tools: Array<{ name: string; description: string; inputSchema: McpToolDoc['inputSchema'] }>,
        owner: number,
    ): Promise<void> {
        // Step 1: Clean up existing duplicate tools first
        await this.cleanupDuplicates(domainId, serverId);
        
        // Re-fetch tool list (duplicates cleaned)
        const existingTools = await this.getByServer(domainId, serverId);
        const existingToolMap = new Map<string, McpToolDoc>();
        for (const tool of existingTools) {
            // Ensure only one tool per name in the map
            if (!existingToolMap.has(tool.name)) {
                existingToolMap.set(tool.name, tool);
            }
        }
        
        const newToolNames = new Set(tools.map(t => t.name));

        // Step 2: Process each tool: add new or update existing
        for (const tool of tools) {
            const existingTool = existingToolMap.get(tool.name);
            if (!existingTool) {
                // Double-check if tool exists before adding (prevent concurrency issues)
                const duplicateCheck = await document.getMulti(domainId, document.TYPE_MCP_TOOL, { 
                    serverId, 
                    name: tool.name 
                }).limit(1).toArray();
                
                if (duplicateCheck.length > 0) {
                    // If duplicate found, update existing tool instead of creating new
                    const existing = duplicateCheck[0] as McpToolDoc;
                    logger.warn('Tool %s already exists (toolId: %d), updating instead of creating', tool.name, existing.toolId);
                    await this.update(domainId, serverId, existing.toolId, {
                        description: tool.description,
                        inputSchema: tool.inputSchema,
                    });
                    // Update map
                    existingToolMap.set(tool.name, existing);
                    continue;
                }
                
                // Add new tool
                const newTool = await this.add({
                    domainId,
                    serverId,
                    serverDocId,
                    name: tool.name,
                    description: tool.description,
                    inputSchema: tool.inputSchema,
                    owner,
                });
                // Update map
                existingToolMap.set(tool.name, newTool);
            } else {
                // Update existing tool if description or input schema changed
                const needsUpdate = 
                    existingTool.description !== tool.description ||
                    JSON.stringify(existingTool.inputSchema) !== JSON.stringify(tool.inputSchema);
                
                if (needsUpdate) {
                    await this.update(domainId, serverId, existingTool.toolId, {
                        description: tool.description,
                        inputSchema: tool.inputSchema,
                    });
                }
            }
        }

        // Step 3: Delete tools that no longer exist
        const finalTools = await this.getByServer(domainId, serverId);
        for (const existingTool of finalTools) {
            if (!newToolNames.has(existingTool.name)) {
                // Tool no longer exists in server list, delete it
                logger.info('Removing tool that no longer exists: %s (toolId: %d)', existingTool.name, existingTool.toolId);
                await this.del(domainId, serverId, existingTool.toolId);
            }
        }

        // Step 4: Final cleanup - ensure no duplicates (defensive check)
        const finalDeleted = await this.cleanupDuplicates(domainId, serverId);
        if (finalDeleted > 0) {
            logger.warn('Final cleanup removed %d duplicate tools after sync', finalDeleted);
        }

        const toolsCount = await this.countByServer(domainId, serverId);
        await McpServerModel.update(domainId, serverId, { toolsCount });
        
        logger.info('Tools sync completed: serverId=%d, toolsCount=%d', serverId, toolsCount);
    }
}

export async function apply(ctx: Context) {
    ctx.on('domain/delete', async (domainId) => {
        // Tools are automatically deleted when domain is deleted via server deletion
    });

    if (process.env.NODE_APP_INSTANCE !== '0') return;
}

export default McpServerModel;
export { McpToolModel };

global.Ejunz.model.mcpServer = McpServerModel;
global.Ejunz.model.mcpTool = McpToolModel;

