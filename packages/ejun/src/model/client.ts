import { Filter, ObjectId } from 'mongodb';
import { Context } from '../context';
import { Logger } from '../logger';
import db from '../service/db';
import * as document from './document';
import type { ClientDoc } from '../interface';
import { randomstring } from '../utils';

const logger = new Logger('model/client');

class ClientModel {
    static async generateNextClientId(domainId: string): Promise<number> {
        const lastClient = await document.getMulti(domainId, document.TYPE_CLIENT, {})
            .sort({ clientId: -1 })
            .limit(1)
            .project({ clientId: 1 })
            .toArray();
        return (lastClient[0]?.clientId || 0) + 1;
    }

    static async generateWsToken(): Promise<string> {
        return randomstring(32);
    }

    static async add(client: Partial<ClientDoc> & { domainId: string; name: string; owner: number; edgeId?: number }): Promise<ClientDoc> {
        const clientId = await this.generateNextClientId(client.domainId);
        const now = new Date();
        
        const payload: Partial<ClientDoc> = {
            domainId: client.domainId,
            clientId,
            name: client.name,
            description: client.description,
            wsEndpoint: client.wsEndpoint || `/client/ws`,
            wsToken: client.wsToken || null,
            status: client.status || 'disconnected',
            lastConnectedAt: client.lastConnectedAt,
            lastDisconnectedAt: client.lastDisconnectedAt,
            errorMessage: client.errorMessage,
            edgeId: client.edgeId,
            settings: client.settings || {
                asr: undefined,
                tts: undefined,
                agent: undefined,
            },
            createdAt: now,
            updatedAt: now,
            owner: client.owner,
        };

        // docId is auto-generated by mongo (ObjectId), clientId is business ID (starts from 1)
        await document.add(
            client.domainId,
            client.name, // content
            client.owner,
            document.TYPE_CLIENT,
            null,
            null,
            null,
            payload,
        );

        return await this.getByClientId(client.domainId, clientId) as ClientDoc;
    }

    // Find client by name
    static async getByName(domainId: string, name: string): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { name })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async get(_id: ObjectId): Promise<ClientDoc | null> {
        const doc = await document.coll.findOne({ _id });
        if (!doc) return null;
        return await this.getByClientId(doc.domainId, doc.clientId);
    }

    static async getByDomain(domainId: string): Promise<ClientDoc[]> {
        return await document.getMulti(domainId, document.TYPE_CLIENT, {}).toArray() as ClientDoc[];
    }

    static async getByOwner(domainId: string, owner: number): Promise<ClientDoc[]> {
        return await document.getMulti(domainId, document.TYPE_CLIENT, { owner }).toArray() as ClientDoc[];
    }

    static async update(domainId: string, clientId: number, update: Partial<ClientDoc>): Promise<ClientDoc> {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) throw new Error('Client not found');
        const $set = { ...update, updatedAt: new Date() };
        return await document.set(domainId, document.TYPE_CLIENT, client.docId, $set) as ClientDoc;
    }

    static async updateStatus(
        domainId: string,
        clientId: number,
        status: 'connected' | 'disconnected' | 'error',
        errorMessage?: string,
    ): Promise<ClientDoc> {
        const now = new Date();
        const update: Partial<ClientDoc> = {
            status,
            updatedAt: now,
        };
        if (status === 'connected') {
            update.lastConnectedAt = now;
            update.errorMessage = undefined;
        } else if (status === 'disconnected') {
            update.lastDisconnectedAt = now;
        } else if (status === 'error') {
            update.errorMessage = errorMessage;
        }
        return await this.update(domainId, clientId, update);
    }

    static async updateSettings(
        domainId: string,
        clientId: number,
        settings: Partial<ClientDoc['settings']>,
    ): Promise<ClientDoc> {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) throw new Error('Client not found');
        
        const updatedSettings = {
            ...client.settings,
            ...settings,
        };
        
        return await this.update(domainId, clientId, { settings: updatedSettings });
    }

    static async del(domainId: string, clientId: number) {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) return;
        return await document.deleteOne(domainId, document.TYPE_CLIENT, client.docId);
    }

    static async getByClientId(domainId: string, clientId: number): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { clientId })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async getByEdgeId(domainId: string, edgeId: number): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { edgeId })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async getByWsEndpoint(domainId: string, wsEndpoint: string): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { wsEndpoint })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

}

export async function apply(ctx: Context) {
    ctx.on('domain/delete', async (domainId) => {
        // Clients are automatically deleted when domain is deleted
    });

    if (process.env.NODE_APP_INSTANCE !== '0') return;
}

export default ClientModel;

(global.Ejunz.model as any).client = ClientModel;

