import { Filter, ObjectId } from 'mongodb';
import { Context } from '../context';
import { Logger } from '../logger';
import db from '../service/db';
import * as document from './document';
import type { ClientDoc } from '../interface';
import { randomstring } from '../utils';

const logger = new Logger('model/client');

export interface ClientWidgetDoc {
    _id: ObjectId;
    clientId: number; // 使用clientId而不是ObjectId，因为clientId是业务ID
    domainId: string;
    widgetName: string; // 组件唯一标识
    name: string; // 组件显示名称
    type: string; // 组件类型，如 'switch', 'button', 'display' 等
    state: Record<string, any>; // 组件状态，如 { visible: true }
    capabilities: string[]; // 组件能力，如 ['show', 'hide', 'toggle']
    lastSeen: Date;
    createdAt: Date;
    updatedAt: Date;
}

const collWidget = db.collection('client.widget');

class ClientModel {
    static async generateNextClientId(domainId: string): Promise<number> {
        const lastClient = await document.getMulti(domainId, document.TYPE_CLIENT, {})
            .sort({ clientId: -1 })
            .limit(1)
            .project({ clientId: 1 })
            .toArray();
        return (lastClient[0]?.clientId || 0) + 1;
    }

    static async generateWsToken(): Promise<string> {
        return randomstring(32);
    }

    static async add(client: Partial<ClientDoc> & { domainId: string; name: string; owner: number; edgeId?: number }): Promise<ClientDoc> {
        const clientId = await this.generateNextClientId(client.domainId);
        const now = new Date();
        
        const payload: Partial<ClientDoc> = {
            domainId: client.domainId,
            clientId,
            name: client.name,
            description: client.description,
            wsEndpoint: client.wsEndpoint || `/client/ws`,
            wsToken: client.wsToken || null,
            status: client.status || 'disconnected',
            lastConnectedAt: client.lastConnectedAt,
            lastDisconnectedAt: client.lastDisconnectedAt,
            errorMessage: client.errorMessage,
            edgeId: client.edgeId,
            settings: client.settings || {
                asr: undefined,
                tts: undefined,
                agent: undefined,
            },
            createdAt: now,
            updatedAt: now,
            owner: client.owner,
        };

        // docId is auto-generated by mongo (ObjectId), clientId is business ID (starts from 1)
        await document.add(
            client.domainId,
            client.name, // content
            client.owner,
            document.TYPE_CLIENT,
            null,
            null,
            null,
            payload,
        );

        return await this.getByClientId(client.domainId, clientId) as ClientDoc;
    }

    // Find client by name
    static async getByName(domainId: string, name: string): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { name })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async get(_id: ObjectId): Promise<ClientDoc | null> {
        const doc = await document.coll.findOne({ _id });
        if (!doc) return null;
        return await this.getByClientId(doc.domainId, doc.clientId);
    }

    static async getByDomain(domainId: string): Promise<ClientDoc[]> {
        return await document.getMulti(domainId, document.TYPE_CLIENT, {}).toArray() as ClientDoc[];
    }

    static async getByOwner(domainId: string, owner: number): Promise<ClientDoc[]> {
        return await document.getMulti(domainId, document.TYPE_CLIENT, { owner }).toArray() as ClientDoc[];
    }

    static async update(domainId: string, clientId: number, update: Partial<ClientDoc>): Promise<ClientDoc> {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) throw new Error('Client not found');
        const $set = { ...update, updatedAt: new Date() };
        return await document.set(domainId, document.TYPE_CLIENT, client.docId, $set) as ClientDoc;
    }

    static async updateStatus(
        domainId: string,
        clientId: number,
        status: 'connected' | 'disconnected' | 'error',
        errorMessage?: string,
    ): Promise<ClientDoc> {
        const now = new Date();
        const update: Partial<ClientDoc> = {
            status,
            updatedAt: now,
        };
        if (status === 'connected') {
            update.lastConnectedAt = now;
            update.errorMessage = undefined;
        } else if (status === 'disconnected') {
            update.lastDisconnectedAt = now;
        } else if (status === 'error') {
            update.errorMessage = errorMessage;
        }
        return await this.update(domainId, clientId, update);
    }

    static async updateSettings(
        domainId: string,
        clientId: number,
        settings: Partial<ClientDoc['settings']>,
    ): Promise<ClientDoc> {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) throw new Error('Client not found');
        
        const updatedSettings = {
            ...client.settings,
            ...settings,
        };
        
        return await this.update(domainId, clientId, { settings: updatedSettings });
    }

    static async del(domainId: string, clientId: number) {
        const client = await this.getByClientId(domainId, clientId);
        if (!client) return;
        // 删除client时同时删除相关组件
        await collWidget.deleteMany({ domainId, clientId });
        return await document.deleteOne(domainId, document.TYPE_CLIENT, client.docId);
    }

    static async getByClientId(domainId: string, clientId: number): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { clientId })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async getByEdgeId(domainId: string, edgeId: number): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { edgeId })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

    static async getByWsEndpoint(domainId: string, wsEndpoint: string): Promise<ClientDoc | null> {
        const clients = await document.getMulti(domainId, document.TYPE_CLIENT, { wsEndpoint })
            .limit(1)
            .toArray();
        return (clients[0] as ClientDoc) || null;
    }

}

class ClientWidgetModel {
    static coll = collWidget;

    static async add(widget: Partial<ClientWidgetDoc> & { clientId: number; domainId: string; widgetName: string; name: string; type: string }) {
        const now = new Date();
        const doc: ClientWidgetDoc = {
            _id: new ObjectId(),
            clientId: widget.clientId,
            domainId: widget.domainId,
            widgetName: widget.widgetName,
            name: widget.name,
            type: widget.type,
            state: widget.state || {},
            capabilities: widget.capabilities || [],
            lastSeen: now,
            createdAt: now,
            updatedAt: now,
        };
        await collWidget.insertOne(doc);
        return doc;
    }

    static async get(_id: ObjectId) {
        return collWidget.findOne({ _id });
    }

    static async getByClient(domainId: string, clientId: number) {
        return collWidget.find({ domainId, clientId }).toArray();
    }

    static async getByWidgetName(domainId: string, clientId: number, widgetName: string) {
        return collWidget.findOne({ domainId, clientId, widgetName });
    }

    static async upsertByWidgetName(domainId: string, clientId: number, widgetName: string, update: Partial<ClientWidgetDoc>) {
        const doc = { ...update, updatedAt: new Date(), lastSeen: new Date() };
        return collWidget.updateOne(
            { domainId, clientId, widgetName },
            { $set: doc },
            { upsert: true },
        );
    }

    static async update(_id: ObjectId, update: Partial<ClientWidgetDoc>) {
        const doc = { ...update, updatedAt: new Date(), lastSeen: new Date() };
        return collWidget.updateOne({ _id }, { $set: doc });
    }

    static async updateState(domainId: string, clientId: number, widgetName: string, state: Record<string, any>) {
        return collWidget.updateOne(
            { domainId, clientId, widgetName },
            { $set: { state, updatedAt: new Date(), lastSeen: new Date() } },
        );
    }

    static async del(_id: ObjectId) {
        return collWidget.deleteOne({ _id });
    }

    static async delByClient(domainId: string, clientId: number) {
        return collWidget.deleteMany({ domainId, clientId });
    }

    // 批量注册/更新组件列表
    static async syncWidgets(domainId: string, clientId: number, widgets: Array<{ name: string; type?: string; capabilities?: string[] }>) {
        const now = new Date();
        const operations = widgets.map(widget => {
            const widgetName = typeof widget === 'string' ? widget : widget.name;
            const name = typeof widget === 'string' ? widget : (widget.name || widgetName);
            const type = typeof widget === 'string' ? 'unknown' : (widget.type || 'unknown');
            const capabilities = typeof widget === 'string' ? ['show', 'hide'] : (widget.capabilities || ['show', 'hide']);
            
            return {
                updateOne: {
                    filter: { domainId, clientId, widgetName },
                    update: {
                        $set: {
                            name,
                            type,
                            capabilities,
                            updatedAt: now,
                            lastSeen: now,
                        },
                    },
                    upsert: true,
                },
            };
        });
        
        if (operations.length > 0) {
            await collWidget.bulkWrite(operations);
        }
        
        // 删除不再存在的组件（如果widgets列表中没有，说明已被移除）
        const widgetNames = widgets.map(w => typeof w === 'string' ? w : w.name);
        await collWidget.deleteMany({
            domainId,
            clientId,
            widgetName: { $nin: widgetNames },
        });
        
        return await this.getByClient(domainId, clientId);
    }
}

export async function apply(ctx: Context) {
    ctx.on('domain/delete', async (domainId) => {
        // 删除domain时删除所有相关组件
        await collWidget.deleteMany({ domainId });
        // Clients are automatically deleted when domain is deleted
    });

    if (process.env.NODE_APP_INSTANCE !== '0') return;
    // 创建数据库索引
    await db.ensureIndexes(
        collWidget,
        { key: { domainId: 1, clientId: 1, widgetName: 1 }, name: 'client_widget', unique: true },
        { key: { domainId: 1, clientId: 1 }, name: 'clientId' },
        { key: { domainId: 1 }, name: 'domainId' },
    );
}

export default ClientModel;
export { ClientWidgetModel };

(global.Ejunz.model as any).client = ClientModel;
(global.Ejunz.model as any).clientWidget = ClientWidgetModel;

